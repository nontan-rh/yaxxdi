#include <cstddef>
#include <cstdint>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include <cxxopts.hpp>

namespace fs = std::filesystem;

struct InputFile {
    std::string id;
    fs::path path;

    bool operator<(const InputFile &other) const { return this->id < other.id; }
};

struct GeneratedFile {
    size_t file_index;
    std::string id;
    std::string variable_name;
    size_t size;
};

struct Ctx {
    int max_cols;
    std::string api_prefix;
    std::string include_guard;
    std::string variable_type;
    std::vector<InputFile> input_files;
};

std::string file_index_to_variable_name(size_t file_index) {
    return "file_data_" + std::to_string(file_index);
}

std::string get_find_function_name(const Ctx &ctx) {
    return "yaxxdi_" + ctx.api_prefix + "_find";
}

void generate_header(std::ostream &o, const Ctx &ctx) {
    const auto find_function_name = get_find_function_name(ctx);

    o << "//" << std::endl;
    o << "// generated by yaxxdi" << std::endl;
    o << "//" << std::endl;
    o << std::endl;
    o << "#ifndef " << ctx.include_guard << std::endl;
    o << "#define " << ctx.include_guard << std::endl;
    o << std::endl;
    o << "#ifdef __cplusplus" << std::endl;
    o << "#include <cstddef>" << std::endl;
    o << "#include <cstdint>" << std::endl;
    o << "#else" << std::endl;
    o << "#include <stddef.h>" << std::endl;
    o << "#include <stdint.h>" << std::endl;
    o << "#endif // __cplusplus" << std::endl;
    o << std::endl;
    o << "#ifdef __cplusplus" << std::endl;
    o << "extern \"C\" {" << std::endl;
    o << "#endif // __cplusplus" << std::endl;
    o << std::endl;
    o << "int " + find_function_name + "(const char* id, const "
      << ctx.variable_type << "** data, size_t *size);" << std::endl;
    o << std::endl;
    o << "#ifdef __cplusplus" << std::endl;
    o << "}" << std::endl;
    o << "#endif // __cplusplus" << std::endl;
    o << std::endl;
    o << "#endif // " << ctx.include_guard << std::endl;
}

void generate_source_intro(std::ostream &o, const Ctx &ctx) {
    o << "//" << std::endl;
    o << "// generated by yaxxdi" << std::endl;
    o << "//" << std::endl;
    o << std::endl;
    o << "#include <stddef.h>" << std::endl;
    o << "#include <stdint.h>" << std::endl;
    o << "#include <string.h>" << std::endl;
    o << std::endl;
    o << "typedef struct TAG_YAXXDI_TableEntry {" << std::endl;
    o << "    const char* id;" << std::endl;
    o << "    const uint8_t* data;" << std::endl;
    o << "    size_t size;" << std::endl;
    o << "} YAXXDI_TableEntry;" << std::endl;
}

GeneratedFile generate_source_single_file(std::ostream &o, const Ctx &ctx,
                                          const InputFile &file,
                                          size_t file_index) {
    std::ifstream ifs(file.path);
    if (!ifs) {
        throw std::runtime_error("Could not open file: " + file.path.string());
    }

    auto size = fs::file_size(file.path);

    const std::string variable_name = file_index_to_variable_name(file_index);

    o << std::endl;
    o << "// " << file.id << " - " << file.path.string() << std::endl;

    o << "static " + ctx.variable_type + " " + variable_name + "[] = {"
      << std::endl;

    uintmax_t count = 0;
    for (;;) {
        union {
            char ch;
            uint8_t val;
        } buf;
        ifs.read(&buf.ch, 1);
        if (ifs.eof()) {
            if (count != 0 && count % ctx.max_cols == 0) {
                o << std::endl << "    ";
            }
            o << "0x00";
            break;
        }

        if (!ifs) {
            throw std::runtime_error("Failed to read file at " +
                                     std::to_string(count) +
                                     " in file: " + file.path.string());
        }

        if (count % ctx.max_cols == 0) {
            if (count != 0) {
                o << std::endl;
            }
            o << "    ";
        }

        o << "0x" << std::setfill('0') << std::setw(2) << std::hex
          << (unsigned int)buf.val << std::setfill(' ') << std::setw(0)
          << std::dec << ",";
        ++count;
    }

    o << std::endl;
    o << "};" << std::endl;

    if (size != count) {
        throw std::logic_error("File size and count of read bytes mismatch: (" +
                               std::to_string(size) +
                               " != " + std::to_string(count) + ")" +
                               " for file: " + file.path.string());
    }

    GeneratedFile generated_file;
    generated_file.file_index = file_index;
    generated_file.id = file.id;
    generated_file.variable_name = variable_name;
    generated_file.size = size;

    return generated_file;
}

std::vector<GeneratedFile> generate_source_all_files(std::ostream &o,
                                                     const Ctx &ctx) {
    auto num_files = ctx.input_files.size();
    std::vector<GeneratedFile> generated_files;
    for (size_t file_index = 0; file_index < num_files; file_index++) {
        const auto &file = ctx.input_files[file_index];
        auto generated_file =
            generate_source_single_file(o, ctx, file, file_index);
        generated_files.push_back(generated_file);
    }

    return generated_files;
}

void generate_source_table(std::ostream &o, const Ctx &ctx,
                           const std::vector<GeneratedFile> &generated_files) {
    o << std::endl;
    o << "static YAXXDI_TableEntry yaxxdi_table_entry[] = {" << std::endl;
    auto num_files = ctx.input_files.size();
    for (const auto &generated_file : generated_files) {
        o << "    { \"" << generated_file.id << "\", "
          << generated_file.variable_name << ", " << generated_file.size << " },"
          << std::endl;
    }
    o << "    { NULL, NULL, 0 }," << std::endl;
    o << "};" << std::endl;
}

void generate_source_api(std::ostream &o, const Ctx &ctx,
                         const std::vector<GeneratedFile> &generated_files) {
    const auto find_function_name = get_find_function_name(ctx);

    o << std::endl;
    o << "int " + find_function_name + "(const char* id, const "
      << ctx.variable_type << "** data, size_t *size) {" << std::endl;
    o << "    for (int i = 0; i < " << generated_files.size() << "; i++) {"
      << std::endl;
    o << "        if (strcmp(id, yaxxdi_table_entry[i].id) == 0) {"
      << std::endl;
    o << "            *data = yaxxdi_table_entry[i].data;" << std::endl;
    o << "            *size = yaxxdi_table_entry[i].size;" << std::endl;
    o << "            return 0;" << std::endl;
    o << "        }" << std::endl;
    o << "    }" << std::endl;
    o << std::endl;
    o << "    return 1;" << std::endl;
    o << "}" << std::endl;
}

void generate_source(std::ostream &o, const Ctx &ctx) {
    generate_source_intro(o, ctx);
    auto generated_files = generate_source_all_files(o, ctx);
    generate_source_table(o, ctx, generated_files);
    generate_source_api(o, ctx, generated_files);
}

int main(int argc, char *argv[]) {
    cxxopts::Options options("yaxxdi", "Yet Another `xxd -i'");
    options.add_options()                                               //
        ("directory", "Input directory", cxxopts::value<std::string>()) //
        ("prefix", "API prefix",
         cxxopts::value<std::string>()->default_value("default")) //
        ("guard", "Include guard",
         cxxopts::value<std::string>()->default_value("YAXXDI_H_INCLUDED")) //
        ("source", "Output source file path",
         cxxopts::value<std::string>()->default_value("yaxxdi_resource.c")) //
        ("header", "Output header file path",
         cxxopts::value<std::string>()->default_value("yaxxdi_resource.h")) //
        ("help", "Print help")                                              //
        ;
    const auto args = options.parse(argc, argv);
    if (args.count("help")) {
        std::cout << options.help() << std::endl;
        return 0;
    }

    Ctx ctx;
    ctx.max_cols = 16;
    ctx.variable_type = "uint8_t";
    ctx.api_prefix = args["prefix"].as<std::string>();
    ctx.include_guard = args["guard"].as<std::string>();

    if (args.count("directory")) {
        const auto directory_path =
            fs::path(args["directory"].as<std::string>());
        if (!fs::exists(directory_path)) {
            std::cout << "directory: " << directory_path << " not found"
                      << std::endl;
            return 1;
        }

        for (const auto &entry :
             fs::recursive_directory_iterator(directory_path)) {
            auto status = fs::status(entry);
            if (!fs::is_regular_file(status)) {
                continue;
            }

            InputFile f;
            f.id = fs::relative(entry.path(), directory_path).generic_string();
            f.path = entry.path();
            ctx.input_files.push_back(f);
        }

        std::sort(std::begin(ctx.input_files), std::end(ctx.input_files));
    } else {
        std::cout << "directory is required" << std::endl;
        return 1;
    }

    {
        const auto source_path_str = args["source"].as<std::string>();
        if (source_path_str == "-") {
            generate_source(std::cout, ctx);
        } else {
            std::ofstream ofs(source_path_str);
            if (!ofs) {
                std::cout << "failed to open output source file: "
                          << source_path_str << std::endl;
                return 1;
            }

            generate_source(ofs, ctx);
        }
    }

    {
        const auto header_path_str = args["header"].as<std::string>();
        if (header_path_str == "-") {
            generate_header(std::cout, ctx);
        } else {
            std::ofstream ofs(header_path_str);
            if (!ofs) {
                std::cout << "failed to open output source file: "
                          << header_path_str << std::endl;
                return 1;
            }

            generate_header(ofs, ctx);
        }
    }

    return 0;
}
